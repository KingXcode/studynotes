# iOS断言

> 1. 用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况。
> 2. 避免把需要执行的代码放到断言中
> 3. 用断言来注解并验证前条件和后条件
> 4. 对于高健壮性的代码，应该先使用断言再处理错误

> 对来源于内部系统的可靠的数据使用断言，而不要对外部不可靠的数据使用断言，对于外部不可靠数据，应该使用错误处理代码。断言可以看成可执行的注释。

> 系统外部的数据（用户输入，文件，网络读取等等）都是不可信的，需要严格检查（通常是错误处理）才能放行到系统内部，这相当于一个守卫。而对于系统内部的交互（比如子程序调用），如果每次也都去处理输入的数据，也就相当于系统没有可信的边界了，会让代码变的臃肿复杂；而事实上，在系统内部，传递给子程序预期的恰当数据应该是调用者的责任，系统内的调用者应该确保传递给子程序的数据是恰当可以正常工作的。这样一来，就隔离了不可靠的外部环境和可靠的系统内部环境，降低复杂度。

> 但是在开发阶段，代码极可能包含缺陷，也许是处理外部数据的程序考虑的不够周全，也许是调用系统内部子程序的代码存在错误，造成子程序调用失败。这个时候，断言就可以发挥作用，用来确诊到底是那部分出现了问题而导致子程序调用失败。在清理了所有缺陷之后，内外有别的信用体系就建立起来。等到发行版时候，这些断言就应该没有存在必要。

`NSAssert()`的定义是
`#define NSAssert(condition, desc)`
`condition`是条件表达式，值为`yes`或者`no`，在`OC`中规定0为假，非0就为真。
`desc`为异常描述，为NSString类型。
当`condition`为yes时程序继续运行；
当`condition`为no时程序终止并抛出带有desc描述的异常信息。


```
- 在网上查资料说：
        有些时候，我们仅仅想在Debug版本中使用NSAssert功能，
        而在Release版本中关闭NSAssert功能，
        则可以在Building Settings->Preprocessor Macros中，
        设置Release版本的NS_BLOCK_ASSERTIONS。
- 但我实际试了试Release版本不会产生断言，并不会因为NSAssert而程序crash。
```

